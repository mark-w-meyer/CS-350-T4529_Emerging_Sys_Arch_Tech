# CS-350-T4529_Emerging_Sys_Arch_Tech
A repository of embedded systems artifacts using a Ti SimpleLink CC3220SF MCU. All code was created using Ti Code Composer Studio.

Milestone One

This milestone was solving the problem of implementing a pulse width modulator (PWM). The objective was to blink two LEDs at alternating duty cycles in a loop. What I do particularly well in this milestone is commenting the purpose of each component and keeping the code simple. Where I could improve would be to create a function that updates the duty cycle and make function calls in main to further simplify the code for future expansion of the program. The tools and resources I am adding to my support network are implementing a PWM--which is frequently used in embedded systems engineering--and furthering my experience in using handles and data types such as uint16_t and uint32_t. 

Given the limited space of embedded systems, it is important to become familiar with these data types as well as the handles provided in working with a given manufacturer's product. In this case, since I'm using a Ti MCU, I am programming with a Ti Code Composer Studio, so I am implementing their provided handles to achieve functionality of their product. The skills from this milestone that will be particularly transferable to other projects and/or course work will be adapting to a new environment, increasing my experience in embedded systems implementations, and familiarity with Texas Instruments' microcontrollers and IDE. I made this milestone maintainable, readable, and adaptable by commenting the code well and spacing out the functionality as to easily decipher where important changes in the code are being made such that a future developer could immediately pick up its purpose and intent.

Project Submission

This project was solving the problem of implementing a timer, interrupts, an I2C peripheral, a GPIO peripheral, a UART peripheral, state machines, and a task scheduler along with operational documentation for the task scheduler, and brief analysis of further implementation of the prototype versus other competitors. The problem being solved here is the simulation of a thermostat that sends a report to a server every second (simulated using the UART peripheral). When a button is pressed, the heater is turned on, and when a different button is pressed, the heater is turned off thereby simulating a report of the following: <room temp, temp set-point, heat status, time elapsed>. The temperature is in Celcius, and the heat status is reported as "0" for off and "1" for on. The time elapsed is in seconds; however, the application uses microseconds to perform operations. The task scheduler in this project manages three state machines to manage interrupts and peripherals.

What I did particularly well was organizing the code in a way that made sense to keep maintainability and readability. For example, all global variables and structs are at the top; then interrupts, state machines/enums, and peripherals are initialized/declared; then, functions such as reading the temperature and the timer callback are implemented; next, main is called where the task scheduler performs operations; finally, all three state machines are under main to keep them separate from everything else. Where I could improve would be to put the task scheduler in its own function to clean up main a bit. I would also liked to have separated each peripheral into separate files for a more object-oriented approach; however, the project was designed such that we were to follow specific guidelines, so I held to those standards. The tools and/or resources I am adding to my support network are the implementations of a timer, interrupts, an I2C peripheral, a GPIO peripheral, a UART peripheral, state machines, and a task scheduler as well as furthering my experience in designing and programming embedded systems using a Ti microcontroller and IDE.

The skills from this project that will be particularly transferable to other projects and/or course work will be organization and implementation of embedded systems applications, relevant documentation, embedded systems analyses, embedded systems tools, and the overall experience of adapting to a new technology (that being embedded systems in general). I made this project maintainable, readable, and adaptable by organizing the application using industry-standard best practices and by commenting thoroughly in communicating the purpose and intent of the code.
